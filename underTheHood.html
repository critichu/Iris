<p><img src="resources/icon_256x256.png" alt="iris logo"></p>

<h1 id="toc_0">Iris under the hood</h1>

<h2 id="toc_1">Iris workflow</h2>

<p>Generally, Iris follows the following steps:</p>

<ul>
<li>crops image (to keep only colony array)</li>
<li>cuts (segments) cropped image into tiny images (tiles), each holding one colony</li>
<li>analyzes each tile independently to get size other phenotypic characteristics</li>
</ul>

<p><img src="resources/process.overview.png" alt="iris workflow"></p>

<h2 id="toc_2">Iris design</h2>

<p>Iris was designed in a modular fashion; in other words, the above worflow steps are separate modules that one can plug in, modify, and replace at will.  </p>

<p><img src="resources/iris.design.jpeg" alt="iris design 1"></p>

<h3 id="toc_3">module interoperability</h3>

<p>To help new/modified modules connect in the same way to the profile class, I use <em>connecting classes</em>, such as <strong>TileReaderInput</strong> and <strong>TileReaderOutput</strong> (illustrated as green and pink shapes in the above)<br>
These connecting classes only need to be extended if you add new readouts not already covered by existing connecting subclasses.</p>

<p><img src="resources/iris.design2.jpeg" alt="iris design 2"></p>

<h2 id="toc_4">Algorithms used per profile</h2>

<p>Each profile calls different modules (as illustrated above), but different profiles can call on the same modules.<br>
Here is a table listing the algorithms used per profile: 
<img src="resources/iris.profiles.algorithms.used.crop.png" alt="Iris algorithms"></p>
